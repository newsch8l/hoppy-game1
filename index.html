<!doctype html>
<html lang="ru">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Hoppy — Level Selector & Slow L4</title>
<style>
  html, body { height: 100%; margin: 0; background: #0d0f12; }
  .wrap { position: fixed; inset: 0; display: grid; place-items: center; }
  #cv { display: block; background: #e9edf2; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.25); touch-action: none; }
</style>
<div class="wrap"><canvas id="cv"></canvas></div>
<script>
// ==========================================
// 1. ГЛОБАЛЬНЫЕ НАСТРОЙКИ
// ==========================================
const BASE_W = 400, BASE_H = 700;
const BASE_PLAYER_W = 200, BASE_PLAYER_H = 243;
const VISUAL_SCALE = 0.75;
let DPR = Math.max(1, Math.round(window.devicePixelRatio || 1));

// Физика
const G=2200, JUMP_VY=-770, SPEED_X=220, MAX_FALL=1400, MAX_RISE=1000;
const MAX_JUMP_PX = Math.floor((JUMP_VY*JUMP_VY) / (2*G));
const MIN_OVERLAP=9, TOP_TOLERANCE=2.5;
const FRICTION_GROUND=0.82, FRICTION_AIR=0.985;
const COYOTE=0.08, BUFFER=0.10;
const SLIDE_ACCEL = 150;
const SLIPPERY_TILT_MAX = 0.15;
const SLIPPERY_TILT_THRESHOLD = 12;

// Управление
const MOBILE_SPEED_FACTOR = 0.85;
const AIR_CONTROL_FACTOR = 0.5;
const ACCEL_GROUND_PER_S = 8.0;
const ACCEL_AIR_PER_S = 4.0;
const HOLD_DELAY_MS = 130;
const TAP_MAX_MS = 140;
const NUDGE_DURATION = 0.16;
const NUDGE_SPEED_SCALE = 0.6;

// Анимации
const POP_IN_START = 0.86, POP_IN_OVERSHOOT = 1.04, ALPHA_SOLID_THRESHOLD = 0.95;
const T_PREVIEW=0.18, T_ON=1.20, T_WARN=0.30, T_OFF=0.30, REST_DELAY=0.35;
const CYCLE=T_PREVIEW+T_ON+T_WARN+T_OFF, CYCLE_EXT=CYCLE+REST_DELAY;
const APPEAR_SOLID_DELAY=0.05, VANISH_COYOTE=0.10;
const SCALE_GREEN = 0.18, SCALE_YELLOW = 0.205;

// ==========================================
// 2. БАЗОВЫЕ ФУНКЦИИ (HELPERS)
// ==========================================
function applyFriction(vx, onGround, dt){ 
  const k = Math.pow(onGround ? FRICTION_GROUND : FRICTION_AIR, dt*60); 
  return Math.abs(vx) < 1 ? 0 : vx * k; 
}

function easeOutBack(t){ const c1=1.70158, c3=c1+1; return 1 + c3*Math.pow(t-1,3) + c1*Math.pow(t-1,2); }
function easeInQuad(t){ return t*t; }

function roundRectPath(x,y,w,h,r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath(); ctx.moveTo(x+rr, y); ctx.arcTo(x+w, y, x+w, y+h, rr); ctx.arcTo(x+w, y+h, x, y+h, rr); ctx.arcTo(x, y+h, x, y, rr); ctx.arcTo(x, y, x+w, y, rr); ctx.closePath();
}

function drawOutlinedText(ctx,text,x,y,opt){
  opt = opt || {};
  ctx.save(); 
  ctx.font = opt.font || 'bold 14px system-ui';
  ctx.textAlign = opt.align || 'center';
  ctx.textBaseline = opt.baseline || 'middle';
  ctx.lineWidth = opt.width || 3; 
  ctx.strokeStyle = opt.stroke || 'rgba(0,0,0,0.95)'; 
  ctx.lineJoin='round'; ctx.miterLimit=2; 
  ctx.strokeText(text,x,y);
  ctx.fillStyle = opt.fill || '#fff'; 
  ctx.fillText(text,x,y); 
  ctx.restore();
}

function getTimerTotal(level){
  if(level===1) return 12.0;
  if(level===2) return 10.0;
  if(level===3) return 8.5;
  if(level===4) return 12.0; // ~12 sec on level 4
  if(level===5) return 13.0;
  return 8.5;
}

// ==========================================
// 3. ИНИЦИАЛИЗАЦИЯ
// ==========================================
const c = document.getElementById('cv');
let ctx = c.getContext('2d', { alpha: true });
ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';

let W = BASE_W, H = BASE_H;
let gameState = 'menu'; // Start in MENU state
let timeSec=0, lastGroundTime=-1, lastJumpPress=-1;
let timerElapsed=0;
let TIMER_TOTAL = 12.0;

const hoppy = { img: new Image(), ready: false, naturalW: 0, naturalH: 0 };
const player = { x: 0, y: 20, w: BASE_PLAYER_W, h: BASE_PLAYER_H, vx:0, vy: 20, dir:1, on:false, jumpHeld:false, ground:null };
const keys = { left:false, right:false, up:false };
let overrideMove = { active:false, side:0, until:0 };

let cameraY = 0, cameraMaxY = 0;
let platforms = [];
let currentLevel = 1;
const LAST_LEVEL = 5;
let cookie = null;

// Assets
hoppy.img.src = "assets/hoppy.png";
const SPRITES = { green: [], yellow: [] };
const finish = { x:60, y: 20, w:280, h:44 };
let cancelImg = new Image();
let cancelImgOK = false;
cancelImg.onload = ()=>{ cancelImgOK = true; };
cancelImg.src = "assets/cancel.png";

const OVERLAY = {
  win:  { img: new Image(), ready: false },
  lose: { img: new Image(), ready: false }
};
OVERLAY.win.img.src  = "assets/continue.png";
OVERLAY.lose.img.src = "assets/gameover.png";
let uiButtons=[];
let overlayClock = 0;

(function loadPacks(){
  ["assets/green_1.png","assets/green_2.png","assets/green_3.png"].forEach(fn=>{
    const i = new Image(); i.onload=()=>i._ok=true; i.onerror=()=>i._ok=false; i.src=fn; SPRITES.green.push(i);
  });
  ["assets/yellow_1.png","assets/yellow_2.png","assets/yellow_3.png"].forEach(fn=>{
    const i=new Image(); i.onload=()=>i._ok=true; i.onerror=()=>i._ok=false; i.src=fn; SPRITES.yellow.push(i);
  });
})();

// ==========================================
// 4. УПРАВЛЕНИЕ
// ==========================================
const IS_TOUCH = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

(function(){
  const DEADZONE = 16;
  const DEADZONE_DEACTIVATE = DEADZONE * 0.55;
  const PATH_MIN = 40;
  const UP_MIN = 32;
  const VERT_DOM_RATIO = 1.05;
  const DIAG_X_MIN = 28;
  const DIAG_RATIO = 0.65;
  const JUMP_SWipe_MIN = 40;
  const JUMP_SWipe_MAX = 160;
  const JUMP_SCALE_MIN = 1.0;
  const JUMP_SCALE_MAX = 1.18;
  const RECENTER_DIST = 120;

  let activeId = null;
  let originX = 0, originY = 0;
  let lastX = 0, lastY = 0;
  let startTS = 0;
  let didJump = false;
  let moveActive = false;
  let holdTimer = null;

  function canvasPos(t){
    const r = c.getBoundingClientRect();
    return { x: (t.clientX - r.left), y: (t.clientY - r.top), w: r.width, h: r.height };
  }
  function engageMoveBy(dx, w){
    const side = (dx < 0) ? -1 : +1;
    if(side < 0){ keys.left = true; keys.right = false; player.dir = -1; }
    else { keys.right = true; keys.left = false; player.dir = +1; }
    moveActive = true;
  }
  function stopMove(){ keys.left = false; keys.right = false; moveActive = false; }
  function jumpWithStrength(absSwipeY, dx, w){
    let t = (absSwipeY - JUMP_SWipe_MIN) / Math.max(1, (JUMP_SWipe_MAX - JUMP_SWipe_MIN));
    t = Math.max(0, Math.min(1, t));
    const scale = JUMP_SCALE_MIN + (JUMP_SCALE_MAX - JUMP_SCALE_MIN) * t;
    lastJumpPress = timeSec; player.jumpHeld = true; keys.up = true;
    const absX = Math.abs(dx);
    if(absX >= DIAG_X_MIN && (absX / Math.max(1, absSwipeY)) >= DIAG_RATIO){
      engageMoveBy(dx, w);
    }
    didJump = true;
    player._pendingJumpScale = scale;
  }
  window._applyPendingJumpScale = function(){
    if(typeof player._pendingJumpScale === 'number' && player.vy < 0){
      player.vy *= player._pendingJumpScale;
      delete player._pendingJumpScale;
    }
  };

  c.addEventListener('touchstart', (e)=>{
    if(activeId !== null) return;
    const t = e.changedTouches[0]; const p = canvasPos(t);
    activeId = t.identifier; originX = lastX = p.x; originY = lastY = p.y;
    startTS = performance.now(); didJump = false; moveActive = false;
    if(holdTimer){ clearTimeout(holdTimer); holdTimer = null; }
    
    // Menu Interaction
    if(gameState === 'menu'){
        // Handled by global click/touch handler
        return;
    }
    
    if(gameState === 'play'){
      holdTimer = setTimeout(()=>{
        if(activeId !== null && !didJump && !moveActive){
          const dx = lastX - originX;
          if(Math.hypot(dx, 0) > DEADZONE){ engageMoveBy(dx, p.w); }
        }
      }, HOLD_DELAY_MS);
      e.preventDefault();
    }
  }, { passive:false });

  c.addEventListener('touchmove', (e)=>{
    if(activeId === null) return;
    let t = null; for(const tt of e.changedTouches){ if(tt.identifier === activeId){ t = tt; break; } }
    if(!t) return;
    const p = canvasPos(t);
    const dx = p.x - originX, dy = p.y - originY;
    lastX = p.x; lastY = p.y;
    if(gameState === 'play'){
      const absX = Math.abs(dx), absY = Math.abs(dy);
      const pathLen = Math.hypot(dx, dy);
      if(pathLen > RECENTER_DIST && !moveActive && !keys.left && !keys.right && !didJump){
        originX = p.x; originY = p.y;
      }
      if(didJump){
        if(absX > DEADZONE * 1.1){ engageMoveBy(dx, p.w); }
        e.preventDefault(); return;
      }
      const pureUp = (pathLen > PATH_MIN) && (-dy > UP_MIN) && (absY > absX * VERT_DOM_RATIO);
      const diagUp = (-dy > UP_MIN) && (absX >= DIAG_X_MIN) && ((absX/Math.max(1,absY)) >= DIAG_RATIO);
      if(pureUp || diagUp){
        if(holdTimer){ clearTimeout(holdTimer); holdTimer = null; }
        jumpWithStrength(absY, dx, p.w);
        e.preventDefault(); return;
      }
      if(absX > DEADZONE && absX >= absY * 0.8){
        if(holdTimer){ clearTimeout(holdTimer); holdTimer = null; }
        engageMoveBy(dx, p.w);
      } else if(absX <= DEADZONE_DEACTIVATE && !didJump && moveActive){
        stopMove();
      }
      e.preventDefault();
    }
  }, { passive:false });

  function endTouch(){
    if(holdTimer){ clearTimeout(holdTimer); holdTimer = null; }
    stopMove();
    if(keys.up){ keys.up = false; player.jumpHeld = false; if(player.vy < 0) player.vy *= 0.55; }
    activeId = null;
  }
  c.addEventListener('touchend', (e)=>{
    let has = false; for(const tt of e.changedTouches){ if(tt.identifier === activeId){ has = true; break; } }
    if(!has) return; if(gameState === 'play'){ e.preventDefault(); } endTouch();
  }, { passive:false });
  c.addEventListener('touchcancel', (e)=>{
    let has = false; for(const tt of e.changedTouches){ if(tt.identifier === activeId){ has = true; break; } }
    if(!has) return; if(gameState === 'play'){ e.preventDefault(); } endTouch();
  }, { passive:false });
})();

// ==========================================
// 5. ЛОГИКА УРОВНЕЙ
// ==========================================
function resizeCanvas(){
  DPR = Math.max(1, Math.round(window.devicePixelRatio || 1));
  const vw = Math.max(320, window.innerWidth);
  const vh = Math.max(480, window.innerHeight);
  const aspect = BASE_W / BASE_H;
  let cssW, cssH;
  if (IS_TOUCH && vh >= vw) {
    const deviceAspect = vw / vh;
    if (deviceAspect >= 0.52) { cssH = Math.min(vh, 900); cssW = Math.round(cssH * aspect); }
    else { cssW = vw - 24; cssH = Math.round(cssW / aspect); }
  } else {
    cssH = Math.min(vh - 24, 900); cssW = Math.round(cssH * aspect);
    if (cssW > vw - 24) { cssW = vw - 24; cssH = Math.round(cssW / aspect); }
  }
  c.style.width = cssW + 'px'; c.style.height = cssH + 'px';
  c.width = Math.round(cssW * DPR); c.height = Math.round(cssH * DPR);
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality = 'high';
  W = cssW; H = cssH;
  recalcPlayerSize();
}
addEventListener('resize', resizeCanvas, { passive:true });

function recalcPlayerSize(){
  if(!hoppy || !hoppy.ready){ return; }
  const s = H / BASE_H;
  const effectiveDPR = IS_TOUCH ? Math.min(DPR, 2) : DPR;
  const maxCssH = Math.floor(hoppy.naturalH / effectiveDPR);
  const maxCssW = Math.floor(hoppy.naturalW / effectiveDPR);
  player.h = Math.max(1, Math.floor(Math.min(Math.round(BASE_PLAYER_H * s), maxCssH) * VISUAL_SCALE));
  player.w = Math.max(1, Math.floor(Math.min(Math.round(BASE_PLAYER_W * s), maxCssW) * VISUAL_SCALE));
  player.x = Math.max(0, Math.min(BASE_W - player.w, player.x||0));
  player.y = Math.max(-99999, Math.min(99999, player.y||0));
  updateHitboxOffsets();
}

let HITBOX_OFFSET_X = 34, HITBOX_OFFSET_Y = 0;
let RENDER_FEET_OVERLAP = 18;
function updateHitboxOffsets(){
  const kx = player.w / BASE_PLAYER_W; const ky = player.h / BASE_PLAYER_H;
  HITBOX_OFFSET_X = Math.round(34 * kx); HITBOX_OFFSET_Y = Math.round(0 * ky);
  RENDER_FEET_OVERLAP = Math.round(18 * ky);
}
function getHitbox(){ return { x:player.x+HITBOX_OFFSET_X, y:player.y+HITBOX_OFFSET_Y, w:player.w-HITBOX_OFFSET_X*2, h:player.h-HITBOX_OFFSET_Y }; }

function assignSizeFromSprite(p){
  const pack = SPRITES[p.spriteColor];
  const img = (pack && pack.length) ? pack[p.spriteIndex % pack.length] : null;
  if(img && img._ok){
    const s = (p.spriteColor === 'yellow') ? SCALE_YELLOW : SCALE_GREEN;
    p.w = Math.max(1, Math.round(img.naturalWidth * s));
    p.h = Math.max(1, Math.round(img.naturalHeight * s));
  } else {
    p.w = 180; p.h = 20;
  }
}
function recomputeSizesWhenReady(){
  const all = [...SPRITES.green, ...SPRITES.yellow];
  if(all.every(i => i && i._ok)) { for(const p of platforms){ assignSizeFromSprite(p); } }
  else { setTimeout(recomputeSizesWhenReady, 30); }
}

function buildLevel1(){
  platforms = [];
  function addGreen(x,y,idx){ const g={ x:x, y:y, perm:true, spriteColor:'green', spriteIndex:(idx||0)%3 }; assignSizeFromSprite(g); platforms.push(g); return g; }
  function addSlippery(x,y,idx){ const s={ x:x, y:y, perm:true, spriteColor:'green', spriteIndex:(idx||0)%3, slippery:true, tilt:0, targetTilt:0 }; assignSizeFromSprite(s); platforms.push(s); return s; }
  const left = 50, right = 230; const safeBottom = H - 280; const gapY = 130;
  addGreen(left, safeBottom, 0); addGreen(right, safeBottom - gapY, 1);
  addGreen(left, safeBottom - 2*gapY, 2); addGreen(right, safeBottom - 3*gapY, 0);
  cameraY = 0; cameraMaxY = 0;
}
function buildLevel2(){
  platforms = [];
  function addGreen(x,y,idx){ const g={ x:x, y:y, perm:true, spriteColor:'green', spriteIndex:(idx||0)%3 }; assignSizeFromSprite(g); platforms.push(g); return g; }
  function addYellow(x,y){ const yel={ x:x, y:y, perm:false, spriteColor:'yellow', spriteIndex:2, phaseOffset:0.15, state:'off', prevState:'off', tLocal:0, grace:0, solidDelay:20, waitExit:false, anim:{alpha:0, scale:1, phase:'out', t:0, dur:0} }; assignSizeFromSprite(yel); platforms.push(yel); return yel; }
  function addSlippery(x,y,idx){ const s={ x:x, y:y, perm:true, spriteColor:'green', spriteIndex:(idx||0)%3, slippery:true, tilt:0, targetTilt:0 }; assignSizeFromSprite(s); platforms.push(s); return s; }
  const left = 50, right = 230; const safeBottom = H - 220; const gapY = 120;
  addGreen(left, safeBottom, 0); addGreen(right, safeBottom - gapY, 1);
  addYellow(140, safeBottom - 2*gapY + 5);
  addGreen(left, safeBottom - 3*gapY, 2); addGreen(right, safeBottom - 4*gapY, 0);
  cameraY = 0; cameraMaxY = 0;
}
const BUTTON_WORLD_Y = 12;

// --- УРОВЕНЬ 3 ---
function buildLevel3(){
  platforms = [];
  finish.y = BUTTON_WORLD_Y;

  function addGreen(x,y,idx){ const g={x:x,y:y,perm:true,spriteColor:'green',spriteIndex:(idx||0)%3,anim:{phase:'idle',t:0,dur:0,alpha:1,scale:1}};
    assignSizeFromSprite(g); platforms.push(g); return g;
  }
  function addYellow(x,y,idx,phase){ const yel={x:x,y:y,perm:false,spriteColor:'yellow',spriteIndex:(idx||0)%3,state:'on',t:0,phase:(phase||0),phaseOffset:(phase||0),speed:1 + (((idx||0)%3)-1)*0.06 + ((phase||0)-0.5)*0.04,solidDelay:0,grace:0,waitExit:false,anim:{phase:'idle',t:0,dur:0,alpha:1,scale:1}};
    assignSizeFromSprite(yel); platforms.push(yel); return yel;
  }
  function addSlippery(x,y,idx){ const s={x:x,y:y,perm:true,spriteColor:'green',spriteIndex:(idx||0)%3,slippery:true,tilt:0,targetTilt:0,anim:{phase:'idle',t:0,dur:0,alpha:1,scale:1}};
    assignSizeFromSprite(s); platforms.push(s); return s;
  }
  function addSlippery(x,y,idx){ const s={x:x,y:y,perm:true,spriteColor:'green',spriteIndex:(idx||0)%3,slippery:true,tilt:0,targetTilt:0,anim:{phase:'idle',t:0,dur:0,alpha:1,scale:1}};
    assignSizeFromSprite(s); platforms.push(s); return s;
  }

  const topNoPlatsY = finish.y + MAX_JUMP_PX;
  const left = 40, right = 240;
  const STEPS = 8;
  
  const NORMAL_BASE = Math.min(120, Math.max(90, Math.floor(MAX_JUMP_PX) - 10));
  const BRIDGE_BASE = Math.min(2*Math.floor(MAX_JUMP_PX) - 10, Math.floor(MAX_JUMP_PX) + 56);
  
  function prand(i){ const s=Math.sin((i+0.123)*12.9898)*43758.5453; return s - Math.floor(s); }
  function varyNormal(i){ const d = Math.round((prand(i)-0.5)*10); return Math.max(80, Math.min(NORMAL_BASE + d, Math.floor(MAX_JUMP_PX)-2)); }
  function varyBridge(i){ const d = Math.round((prand(100+i)-0.5)*24); const raw = BRIDGE_BASE + d; const hi = 2*Math.floor(MAX_JUMP_PX) - 6; const lo = Math.floor(MAX_JUMP_PX) + 6; return Math.max(lo, Math.min(raw, hi)); }
  
  const requireMid = new Set([0,2,3,5]);

  const G = new Array(STEPS);
  let y = topNoPlatsY;
  G[0] = addGreen(left, y, 0);
  for (let i=1;i<STEPS;i++){
    const gap = requireMid.has(i-1) ? varyBridge(i-1) : varyNormal(i-1);
    y += gap;
    const x = (i%2===0) ? left : right;
    G[i] = addGreen(x, y+30, i%3);
  }

  // lower G[6] closer to G[7]
  if (G[6]) G[6].y += 20;

  function jitter(i){ const s=Math.sin((i+0.37)*12.9898)*43758.5453; return (s - Math.floor(s)) * 2 - 1; }
  function rand01(i){ const s=Math.sin((i+0.91)*78.233)*43758.5453; return s - Math.floor(s); }
  
  for (let i=0;i<STEPS;i++){
    const p = G[i];
    const baseAmp = (i%2===0) ? 36 : 58;
    let dx = Math.round(jitter(31+i) * baseAmp);
    const edgeBias = (i%2===0) ? -1 : 1;
    const centerBias = (i%2===0) ? 1 : -1;
    const chooseEdge = rand01(100+i) < 0.45;
    const biasAmp = chooseEdge ? (12 + Math.round(rand01(200+i)*16)) : (10 + Math.round(rand01(300+i)*14));
    dx += (chooseEdge ? edgeBias : centerBias) * biasAmp;
    const minX = 8;
    const maxX = BASE_W - (p.w||180) - 8;
    p.x = Math.max(minX, Math.min(maxX, p.x + dx));
  }

  const lerp=(a,b,t)=>Math.round(a*(1-t)+b*t);
  const midY=(a,b)=>Math.round((a+b)/2)+6;
  
  function midAuto(a,b,idx,phaseSeed){
    const t = 0.5 + (prand(a*17+b*31+phaseSeed)-0.5)*0.18;
    addYellow(lerp(G[a].x,G[b].x,t), midY(G[a].y,G[b].y), idx, (prand(999+idx)+phaseSeed*0.01));
  }
  
  if (requireMid.has(0)) midAuto(0,1,2,7);
  if (requireMid.has(2)) midAuto(2,3,1,31);
  if (requireMid.has(3)) midAuto(3,4,0,64);
  if (requireMid.has(5)) midAuto(5,6,1,18);

  let minY = Math.min(finish.y, ...platforms.map(p=>p.y));
  let maxY = Math.max(...platforms.map(p=>p.y + (p.h||0)));
  cameraMaxY = Math.max(0, Math.round((maxY - minY) - H));
  cameraY = Math.max(0, Math.min(cameraMaxY, G[STEPS-1].y - (H - 120)));
}

// --- УРОВЕНЬ 4 (New) ---
function buildLevel4(){
  platforms = [];
  finish.y = BUTTON_WORLD_Y;

  function addGreen(x,y,idx){ const g={x:x,y:y,perm:true,spriteColor:'green',spriteIndex:(idx||0)%3,anim:{phase:'idle',t:0,dur:0,alpha:1,scale:1}};
    assignSizeFromSprite(g); platforms.push(g); return g;
  }
  function addYellow(x,y,idx,phase){ const yel={x:x,y:y,perm:false,spriteColor:'yellow',spriteIndex:(idx||0)%3,state:'on',t:0,phase:(phase||0),phaseOffset:(phase||0),speed:1 + (((idx||0)%3)-1)*0.06 + ((phase||0)-0.5)*0.04,solidDelay:0,grace:0,waitExit:false,anim:{phase:'idle',t:0,dur:0,alpha:1,scale:1}};
    assignSizeFromSprite(yel); platforms.push(yel); return yel;
  }

  const topNoPlatsY = finish.y + MAX_JUMP_PX;
  const left = 40, right = 240;
  const STEPS = 14;
  const NORMAL_BASE = Math.min(120, Math.max(90, Math.floor(MAX_JUMP_PX) - 10));
  const BRIDGE_BASE = Math.min(2*Math.floor(MAX_JUMP_PX) - 10, Math.floor(MAX_JUMP_PX) + 56);
  
  function prand(i){ const s=Math.sin((i+0.123)*12.9898)*43758.5453; return s - Math.floor(s); }
  function varyNormal(i){ const d = Math.round((prand(i)-0.5)*10); return Math.max(80, Math.min(NORMAL_BASE + d, Math.floor(MAX_JUMP_PX)-2)); }
  function varyBridge(i){ const d = Math.round((prand(100+i)-0.5)*24); const raw = BRIDGE_BASE + d; const hi = 2*Math.floor(MAX_JUMP_PX) - 6; const lo = Math.floor(MAX_JUMP_PX) + 6; return Math.max(lo, Math.min(raw, hi)); }
  
  const requireMid = new Set([2, 5, 9, 11]);

  const G = new Array(STEPS);
  let y = topNoPlatsY;
  G[0] = addGreen(left, y, 0);

  for (let i=1;i<STEPS;i++){
    const gap = requireMid.has(i-1) ? varyBridge(i-1) : varyNormal(i-1);
    y += gap;
    const x = (i%2===0) ? left : right;
    G[i] = addGreen(x, y+30, i%3);
  }

  // lower G[6] closer to G[7]
  if (G[6]) G[6].y += 20;

  // Fix G0, G1, G2 vertical spacing to match reference file
  if (G[0] && G[1]) {
    G[1].y = G[0].y + 122; // gap G0->G1
  }
  if (G[1] && G[2]) {
    G[2].y = G[1].y + 115; // gap G1->G2
  }

  function jitter(i){ const s=Math.sin((i+0.37)*12.9898)*43758.5453; return (s - Math.floor(s)) * 2 - 1; }
  function rand01(i){ const s=Math.sin((i+0.91)*78.233)*43758.5453; return s - Math.floor(s); }

  for (let i=0;i<STEPS;i++){
    const p = G[i];
    const baseAmp = (i%2===0) ? 36 : 58;
    let dx = Math.round(jitter(31+i) * baseAmp);
    const edgeBias = (i%2===0) ? -1 : 1;
    const centerBias = (i%2===0) ? 1 : -1;
    const chooseEdge = rand01(100+i) < 0.45;
    const biasAmp = chooseEdge ? (12 + Math.round(rand01(200+i)*16)) : (10 + Math.round(rand01(300+i)*14));
    dx += (chooseEdge ? edgeBias : centerBias) * biasAmp;
    const minX = 8;
    const maxX = BASE_W - (p.w||180) - 8;
    p.x = Math.max(minX, Math.min(maxX, p.x + dx));
  }

  const lerp=(a,b,t)=>Math.round(a*(1-t)+b*t);
  const midY=(a,b)=>Math.round((a+b)/2)+6;

  function midAuto(a,b,idx,phaseSeed){
    const t = 0.5 + (prand(a*17+b*31+phaseSeed)-0.5)*0.18;
    addYellow(lerp(G[a].x,G[b].x,t), midY(G[a].y,G[b].y), idx, (prand(999+idx)+phaseSeed*0.01));
  }

  if (requireMid.has(2)) midAuto(2,3, 0, 0.2);
  
  if (requireMid.has(5)) {
     const ya = G[5].y, yb = G[6].y;
     const xa = G[5].x, xb = G[6].x;
     const gapY = yb - ya;

     // first yellow: ниже, чтобы с неё нельзя было допрыгнуть до верхней зелёной
     let y1 = ya + gapY * 0.35;
     const minDiff = MAX_JUMP_PX + 6;
     if (yb - y1 <= minDiff) {
       y1 = yb - minDiff;
     }
     y1 = Math.max(ya + 32, y1);

     // вторая жёлтая — ближе к верхней зелёной, путь: зелёная -> жёлтая -> жёлтая -> зелёная
     const y2 = ya + gapY * 0.70;

     addYellow(lerp(xa,xb,0.35), y1, 1, 0.0);
     addYellow(lerp(xa,xb,0.65), y2, 2, 0.5);
  }

  if (requireMid.has(9)) midAuto(9,10, 0, 0.75);
  if (requireMid.has(11)) midAuto(11,12, 1, 0.15);

  let minY = Math.min(finish.y, ...platforms.map(p=>p.y));
  let maxY = Math.max(...platforms.map(p=>p.y + (p.h||0)));
  cameraMaxY = Math.max(0, Math.round((maxY - minY) - H));
  cameraY = Math.max(0, Math.min(cameraMaxY, G[STEPS-1].y - (H - 120)));

  // place collectible circle ("cookie") roughly on middle green platform
  cookie = null;
  const greens = platforms.filter(p => p.perm);
  if (greens.length > 0) {
    const mid = greens[Math.floor(greens.length / 2)];
    const w = mid.w || 180;
    cookie = {
      x: mid.x + w * 0.5,
      y: mid.y - 28,
      r: 14,
      taken: false
    };
  }
}

// --- УРОВЕНЬ 5 ---
function buildLevel5(){
  platforms = [];
  finish.y = BUTTON_WORLD_Y;

  function addGreen(x,y,idx){ const g={x:x,y:y,perm:true,spriteColor:'green',spriteIndex:(idx||0)%3,anim:{phase:'idle',t:0,dur:0,alpha:1,scale:1}};
    assignSizeFromSprite(g); platforms.push(g); return g;
  }
  function addYellow(x,y,idx,phase){ const yel={x:x,y:y,perm:false,spriteColor:'yellow',spriteIndex:(idx||0)%3,state:'on',t:0,phase:(phase||0),phaseOffset:(phase||0),speed:1 + (((idx||0)%3)-1)*0.06 + ((phase||0)-0.5)*0.04,solidDelay:0,grace:0,waitExit:false,anim:{phase:'idle',t:0,dur:0,alpha:1,scale:1}};
    assignSizeFromSprite(yel); platforms.push(yel); return yel;
  }
  function addSlippery(x,y,idx){ const s={x:x,y:y,perm:true,spriteColor:'green',spriteIndex:(idx||0)%3,slippery:true,tilt:0,targetTilt:0,anim:{phase:'idle',t:0,dur:0,alpha:1,scale:1}};
    assignSizeFromSprite(s); platforms.push(s); return s;
  }

  const topNoPlatsY = finish.y + MAX_JUMP_PX;
  const left = 40, right = 240;

  const warmA = addGreen(left, topNoPlatsY + 44, 0);
  const warmB = addGreen(right, warmA.y + 116, 1);
  const G0 = addGreen(left, warmB.y + 118, 2);

  const slippery = addSlippery(170, G0.y - 120, 0);
  const Gdown = addGreen(Math.min(BASE_W - 180, slippery.x + 70), G0.y + 90, 1);
  const Gup = addGreen(Math.max(8, slippery.x - 50), slippery.y - 70, 2);

  const upper1 = addGreen(right, Gup.y - 108, 0);
  const upper2 = addGreen(left, upper1.y - 110, 1);
  const upper3 = addGreen(right, upper2.y - 96, 2);

  const midY1 = Math.round((upper1.y + upper2.y) / 2 + 6);
  const midX1 = Math.round((upper1.x + upper2.x) / 2);
  const midY2 = Math.round((upper2.y + upper3.y) / 2 + 8);
  const midX2 = Math.round((upper2.x + upper3.x) / 2);

  addYellow(midX1, midY1, 0, 0.25);
  addYellow(midX2, midY2, 1, 0.65);

  let minY = Math.min(finish.y, ...platforms.map(p=>p.y));
  let maxY = Math.max(...platforms.map(p=>p.y + (p.h||0)));
  cameraMaxY = Math.max(0, Math.round((maxY - minY) - H));
  const bottomPerm = platforms.filter(p=>p.perm).reduce((acc,p)=>(!acc||p.y>acc.y)?p:acc, null);
  const anchorY = bottomPerm ? bottomPerm.y : maxY;
  cameraY = Math.max(0, Math.min(cameraMaxY, anchorY - (H - 120)));

  cookie = null;
  if (Gup) {
    const w = Gup.w || 180;
    cookie = { x: Gup.x + w * 0.5, y: Gup.y - 28, r: 14, taken: false };
  }
}

function shiftPlatformsBy(dy){ for(const p of platforms){ p.y = Math.round(p.y + dy); } }
function setLevel(n){
  currentLevel = n; timeSec = 0; timerElapsed = 0; gameState='play'; cookie = null; player.ground = null;
  if(n === 1) buildLevel1();
  else if(n === 2) buildLevel2();
  else if(n === 3) buildLevel3();
  else if(n === 4) buildLevel4();
  else if(n === 5) buildLevel5();
  
  if(n===1 || n===2){
    const shiftK = IS_TOUCH ? 0.12 : 0.05;
    shiftPlatformsBy(H * shiftK);
  }
  recomputeSizesWhenReady(); spawnOnBottomPlatform();
}
function timerProgress(){ return Math.max(0, Math.min(1, timerElapsed/TIMER_TOTAL)); }

// ==========================================
// 6. АНИМАЦИИ (UPDATE)
// ==========================================
function setAnim(p,phase,dur){ if(!p.anim) p.anim={}; p.anim.phase=phase; p.anim.t=0; p.anim.dur=dur; if(phase==='out'){ p.anim.alpha = 0; } }
function updateAnim(p,dt){
  if(!p.anim) return; p.anim.t += dt;
  if(p.anim.phase==='in'){
    const t=Math.min(1,p.anim.t/Math.max(0.0001,p.anim.dur)); const e=easeOutBack(t); p.anim.alpha=t;
    const s=POP_IN_START + (POP_IN_OVERSHOOT-POP_IN_START)*e; p.anim.scale = (t<0.9)?s:(1 + (s-1)*(1 - (t-0.9)/0.1));
    if(t>=1){ p.anim.phase='idle'; p.anim.alpha=1; p.anim.scale=1; }
  } else if(p.anim.phase==='pulse'){
    const amp=0.02; p.anim.scale=1 + Math.sin(timeSec*10)*amp; p.anim.alpha=1;
  } else if(p.anim.phase==='out'){
    const t=Math.min(1,p.anim.t/Math.max(0.0001,p.anim.dur)); p.anim.scale = 1 - 0.5 * easeInQuad(t); p.anim.alpha = (t < 0.98) ? 1 : 0;
  } else { p.anim.alpha=1; p.anim.scale=1; }
}
function platformPhaseNow(p){ const base=(timeSec+(p.phaseOffset||0)*CYCLE_EXT); return (base)%CYCLE_EXT; }
function updateBridgeState(p,dt,playerHB){
  if(p.perm) return; p.tLocal=platformPhaseNow(p); const t=p.tLocal;
  const newState=(t<T_PREVIEW)?'preview':(t<T_PREVIEW+T_ON)?'on':(t<T_PREVIEW+T_ON+T_WARN)?'warn':(t<CYCLE)?'off':'rest';
  if(newState!==p.state){
    p.prevState=p.state; p.state=newState;
    if(p.state==='preview'){ p.solidDelay=APPEAR_SOLID_DELAY; p.waitExit=false; setAnim(p,'in',T_PREVIEW); p.anim.alpha=0; p.anim.scale=POP_IN_START; }
    if(p.state==='on'){ p.solidDelay=Math.max(0,p.solidDelay); p.anim.phase='idle'; p.anim.alpha=1; p.anim.scale=1; }
    if(p.state==='warn'){ p.anim.phase='pulse'; }
    if(p.state==='off'){ p.grace=VANISH_COYOTE; p.solidDelay=0; p.waitExit=false; setAnim(p,'out',T_OFF); }
    if(p.state==='rest'){ p.anim.phase='out'; p.anim.alpha=0; p.anim.scale=1; }
  }
  if(p.solidDelay>0)p.solidDelay=Math.max(0,p.solidDelay-dt);
  if(p.grace>0)p.grace=Math.max(0,p.grace-dt);
  if(p.state==='preview' && p.anim && p.anim.alpha < ALPHA_SOLID_THRESHOLD){ p.solidDelay = Math.max(p.solidDelay, 0.016); }
  if((p.state==='on'||p.state==='warn')&&p.waitExit){
    if(playerHB){
      const ow=Math.min(playerHB.x+playerHB.w,p.x+p.w)-Math.max(playerHB.x,p.x);
      const oh=Math.min(playerHB.y+playerHB.h,p.y+p.h)-Math.max(playerHB.y,p.y);
      if(ow>0&&oh>0) p.solidDelay=Math.max(p.solidDelay,0.016); else {p.waitExit=false; p.solidDelay=0;}
    }else{p.waitExit=false; p.solidDelay=0;}
  }
  updateAnim(p, dt);
}
function bridgeIsSolidForLanding(p){
  if(p.perm) return true;
  if((p.state==='on'||p.state==='warn')&&p.solidDelay===0) return true;
  if(p.state==='preview' && p.solidDelay===0 && p.anim && p.anim.alpha>=ALPHA_SOLID_THRESHOLD) return true;
  if(p.grace>0) return true;
  return false;
}

// ==========================================
// 7. ОТРИСОВКА (RENDER)
// ==========================================
function drawButton(){
  if (!cancelImgOK) return;
  const targetW = Math.round(BASE_W * 0.6825); 
  const ar = cancelImg.height / cancelImg.width;
  const targetH = Math.round(targetW * ar);
  finish.w = targetW; finish.h = targetH; 
  finish.x = Math.round((W - finish.w) / 2);
  ctx.save(); if(currentLevel >= 3){ ctx.translate(0, -cameraY); }
  ctx.drawImage(cancelImg, finish.x, finish.y, finish.w, finish.h);
  ctx.restore();
}

function drawTimer(){
  const p = timerProgress();
  const pad = 8, barH = 24, radius = 12;
  
  const maxBarW = BASE_W - 40;
  const screenBarW = W * 0.85;
  const barW = Math.round(Math.min(maxBarW, screenBarW));
  
  const x = Math.round((W - barW) / 2);
  const y = H - pad - barH;
  
  ctx.save(); roundRectPath(x, y, barW, barH, radius); ctx.fillStyle = '#e6e8eb'; ctx.globalAlpha = 0.85; ctx.fill(); ctx.globalAlpha = 1;
  ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.stroke(); ctx.restore();
  const fillW = Math.max(0, Math.floor(barW * p));
  if (fillW > 0){
    let col = '#2ecc71'; if (p >= 0.7 && p < 0.9) col = '#f1c40f'; if (p >= 0.9) col = '#c0392b';
    if (p >= 0.9){ const blink = (Math.sin(timeSec * 10) * 0.5 + 0.5); ctx.globalAlpha = 0.75 + 0.25 * blink; }
    const rr = Math.min(radius, fillW/2, barH/2);
    ctx.save(); roundRectPath(x, y, fillW, barH, rr); ctx.fillStyle = col; ctx.fill(); ctx.globalAlpha = 1; ctx.restore();
    ctx.save(); roundRectPath(x, y, fillW, barH, rr); ctx.lineWidth = 1.5; ctx.strokeStyle = 'rgba(0,0,0,0.20)'; ctx.stroke(); ctx.restore();
  }
  drawOutlinedText(ctx, 'Очистка системы: ' + Math.floor(p*100) + '%', x + barW/2, y + barH/2, {
    font: 'bold 14px system-ui', baseline: 'middle', align: 'center', fill: '#fff', stroke: 'rgba(0,0,0,0.95)', width: 3
  });
  if (p >= 0.9) {
    const blink = (Math.sin(timeSec * 10) * 0.5 + 0.5);
    const redAlpha = 0.10 + 0.20 * blink;
    ctx.save(); ctx.fillStyle = `rgba(255,0,0,${redAlpha.toFixed(2)})`;
    ctx.fillRect(0, 0, W, H); ctx.restore();
  }
}

function drawPlatformSprite(p, offsetX){
  const pack = SPRITES[p.spriteColor];
  const img = (pack && pack.length>0) ? pack[p.spriteIndex % pack.length] : null;
  const worldX = Math.round(offsetX + p.x);
  const worldY = Math.round(p.y - (currentLevel >= 3 ? cameraY : 0));
  const w = Math.round(p.w||180), h = Math.round(p.h||20);
  if(p.perm){
    ctx.save();
    if(img && img._ok){ ctx.drawImage(img, worldX, worldY, w, h); }
    else { ctx.fillStyle='#2e7d32'; ctx.fillRect(worldX, worldY, w, h); }
    ctx.restore(); return;
  }
  const alpha = p.anim ? p.anim.alpha : 1; const scale = p.anim ? p.anim.scale : 1;
  if(p.state==='off' && alpha<=0.01) return;
  ctx.save(); ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
  const cx = worldX + w/2, cy = worldY + h/2;
  ctx.translate(cx, cy);
  if(p.slippery) ctx.rotate(p.tilt || 0);
  ctx.scale(scale, scale);
  if(img && img._ok){ ctx.drawImage(img, -w/2, -h/2, w, h); }
  else { ctx.fillStyle='#f1c40f'; ctx.fillRect(-w/2, -h/2, w, h); }
  ctx.restore();
}
function drawCookie(offsetX){
  if (!cookie || cookie.taken || (currentLevel !== 4 && currentLevel !== 5)) return;
  const worldX = Math.round(offsetX + cookie.x);
  const worldY = Math.round(cookie.y - (currentLevel >= 3 ? cameraY : 0));
  const r = cookie.r || 14;
  ctx.save();
  ctx.fillStyle = '#ffd27f';
  ctx.beginPath();
  ctx.arc(worldX, worldY, r, 0, Math.PI * 2);
  ctx.fill();
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(0,0,0,0.25)';
  ctx.stroke();
  ctx.restore();
}

function drawPlatforms(offsetX){
  for(const p of platforms){
    if(!p.perm && (p.state==='rest' || (p.state==='off' && (!p.anim || p.anim.alpha<=0.01)))) continue;
    drawPlatformSprite(p, offsetX);
  }
}

function drawHoppy(offsetX){
  ctx.save(); ctx.translate(offsetX, -(currentLevel >= 3 ? cameraY : 0));
  if (hoppy.ready){
    const flipLeft = (player.dir===-1);
    const baseX = Math.round(player.x);
    const drawX = flipLeft ? baseX + player.w : baseX;
    const drawY = Math.round(player.y + (typeof RENDER_FEET_OVERLAP!=='undefined'?RENDER_FEET_OVERLAP:0));
    const vy = (typeof player.vy==='number') ? player.vy : 0;
    let targetY = 1 + Math.max(-0.12, Math.min(0.12, -vy / 850));
    targetY = Math.max(0.93, Math.min(1.12, targetY));
    const targetX = 1 / targetY;
    if (!player._scaleY) { player._scaleY = 1; player._scaleX = 1; }
    player._scaleY += (targetY - player._scaleY) * 0.12;
    player._scaleX += (targetX - player._scaleX) * 0.12;
    const cx = drawX + (flipLeft ? -player.w/2 : player.w/2);
    const cy = drawY + player.h/2;
    ctx.save(); ctx.translate(cx, cy); if (flipLeft) ctx.scale(-1, 1); ctx.scale(player._scaleX, player._scaleY); ctx.translate(-cx, -cy);
    if (flipLeft) ctx.drawImage(hoppy.img, drawX - player.w, drawY, player.w, player.h);
    else          ctx.drawImage(hoppy.img, drawX,             drawY, player.w, player.h);
    ctx.restore();
  } else {
    ctx.fillStyle='#2ecc71'; ctx.fillRect(Math.round(player.x),Math.round(player.y),Math.round(player.w),Math.round(player.h));
  }
  ctx.restore();
}
function drawOverlay(title, actions){
  // MENU OVERRIDE: Draw Menu if in menu state
  if(gameState === 'menu'){
    drawMenu();
    return;
  }

  ctx.save(); ctx.globalAlpha = 0.55; ctx.fillStyle = '#000'; ctx.fillRect(0,0,W,H); ctx.restore();
  const kind = (gameState === 'win') ? 'win' : 'lose';
  const bg = OVERLAY[kind];
  const img = bg ? bg.img : null;
  const iW = (bg && bg.w) ? bg.w : 812; const iH = (bg && bg.h) ? bg.h : 535;
  const aspect = iW / iH;
  const maxW = Math.min(W * 0.63, 294); const maxH = Math.min(H * 0.49, 196);
  let boxW = maxW, boxH = Math.round(maxW / aspect);
  if (boxH > maxH){ boxH = maxH; boxW = Math.round(maxH * aspect); }
  const bx = Math.round((W - boxW)/2); const by = Math.round((H - boxH)/2);
  ctx.globalAlpha = 1.0;
  if (img) ctx.drawImage(img, bx, by, boxW, boxH);
  else { const r = 18; ctx.save(); ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.moveTo(bx+r,by); ctx.arcTo(bx+boxW,by,bx+boxW,by+boxH,r); ctx.arcTo(bx+boxW,by+boxH,bx,by+boxH,r); ctx.arcTo(bx,by+boxH,bx,by,r); ctx.arcTo(bx,by,bx+boxW,by,r); ctx.closePath(); ctx.fill(); ctx.restore(); }
  const padX = Math.round(boxW * 0.09); const padY = Math.round(boxH * 0.18);
  const innerY = by + padY; const innerW = boxW - padX*2; const innerH = boxH - padY - Math.round(boxH*0.10);
  if (gameState === 'win') {
    ctx.save(); ctx.fillStyle = '#2E2E2E'; ctx.font = '700 20px system-ui'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText('УРОВЕНЬ ' + currentLevel, bx + boxW/2, innerY + Math.round(innerH * 0.18)); ctx.restore();
    ctx.save(); ctx.fillStyle = '#2E2E2E'; ctx.font = '600 16px system-ui'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText('Протокол остановлен', bx + boxW/2, innerY + Math.round(innerH * 0.33)); ctx.restore();
  } else {
    ctx.save(); ctx.fillStyle = '#2E2E2E'; ctx.font = '700 20px system-ui'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText(title.text, bx + boxW/2, innerY + Math.round(innerH * 0.24)); ctx.restore();
  }
  uiButtons.length = 0;
  const btnW = Math.max(118, Math.min(136, Math.round(innerW*0.42))); const btnH = 40; const gap = Math.max(12, Math.round(innerW*0.08));
  const yb = innerY + Math.round(innerH*0.60);
  let x0 = bx + (boxW - (actions.length*btnW + (actions.length-1)*gap))/2;
  const w = 2*Math.PI*1.7; const clk = (typeof overlayClock==='number') ? overlayClock : 0;
  const pulse = 1.0 + 0.016 * Math.pow(Math.max(0, Math.sin(clk * w)), 2);
  for (let idx = 0; idx < actions.length; idx++) {
    const a = actions[idx]; const isPrimary = (a.label === 'Дальше');
    const x = x0; const y = yb; const isLose = (gameState === 'lose');
    if ( (gameState === 'win' && isPrimary) || (gameState === 'lose') ) {
      ctx.save(); ctx.translate(x + btnW/2, y + btnH/2); ctx.scale(pulse, pulse); ctx.translate(-(x + btnW/2), -(y + btnH/2));
    }
    const r = 12;
    ctx.beginPath(); ctx.moveTo(x+r, y); ctx.arcTo(x+btnW, y, x+btnW, y+btnH, r); ctx.arcTo(x+btnW, y+btnH, x, y+btnH, r); ctx.arcTo(x, y+btnH, x, y, r); ctx.arcTo(x, y, x+btnW, y, r); ctx.closePath();
    if (isLose) { const grad = ctx.createLinearGradient(0,y,0,y+btnH); grad.addColorStop(0, '#E74C3C'); grad.addColorStop(1, '#FF6B4A'); ctx.fillStyle = grad; ctx.fill(); ctx.lineWidth = 2; ctx.strokeStyle = '#B13A2E'; ctx.stroke(); ctx.restore(); }
    else if (isPrimary) { const grad = ctx.createLinearGradient(0,y,0,y+btnH); grad.addColorStop(0, '#4F8C45'); grad.addColorStop(1, '#67B35B'); ctx.fillStyle = grad; ctx.fill(); ctx.lineWidth = 2; ctx.strokeStyle = '#3E7336'; ctx.stroke(); ctx.restore(); }
    else { ctx.fillStyle = '#E9ECEB'; ctx.fill(); ctx.lineWidth = 2; ctx.strokeStyle = '#4F8C45'; ctx.stroke(); }
    ctx.save();
    if ( (gameState === 'win' && isPrimary) || (gameState === 'lose') ) { ctx.translate(x + btnW/2, y + btnH/2); ctx.scale(pulse, pulse); ctx.translate(-(x + btnW/2), -(y + btnH/2)); }
    ctx.font = '600 15px system-ui'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    if (isLose) { ctx.fillStyle = '#FFFFFF'; } else { ctx.fillStyle = isPrimary ? '#ffffff' : '#4F8C45'; }
    ctx.fillText(a.label, x + btnW/2, y + btnH/2); ctx.restore();
    uiButtons.push({x:x, y:y, w:btnW, h:btnH, action:a.action});
    x0 += btnW + gap;
  }
}

// --- MENU SYSTEM (NEW) ---
function drawMenu(){
  ctx.save();
  // Dark BG
  ctx.fillStyle = '#0d0f12';
  ctx.fillRect(0,0,W,H);
  
  // Title
  ctx.font = '700 32px system-ui';
  ctx.fillStyle = '#fff';
  ctx.textAlign = 'center';
  ctx.fillText('HOPPY', W/2, H*0.25);
  
  // Play Button
  const btnW = 200, btnH = 60;
  const bx = (W - btnW)/2, by = H*0.45;
  
  roundRectPath(bx, by, btnW, btnH, 12);
  ctx.fillStyle = '#2ecc71'; ctx.fill();
  
  ctx.font = '600 24px system-ui';
  ctx.fillStyle = '#fff';
  ctx.fillText('PLAY', W/2, by + btnH/2 + 2);
  
  uiButtons.push({x:bx, y:by, w:btnW, h:btnH, action:'menu_play'});
  
  // Level Selector
  ctx.font = '600 16px system-ui';
  ctx.fillStyle = '#fff';
  ctx.fillText('Select Level:', W/2, H*0.65);
  
  const levels = [1,2,3,4,5];
  const size = 44, gap = 16;
  const totalW = levels.length*size + (levels.length-1)*gap;
  let lx = (W - totalW)/2;
  const ly = H*0.68;
  
  for(let i=0; i<levels.length; i++){
     const lvl = levels[i];
     const isSel = (currentLevel === lvl);
     
     roundRectPath(lx, ly, size, size, 8);
     ctx.fillStyle = isSel ? '#f1c40f' : '#34495e';
     ctx.fill();
     
     ctx.fillStyle = isSel ? '#000' : '#fff';
     ctx.fillText(lvl, lx + size/2, ly + size/2 + 1);
     
     uiButtons.push({x:lx, y:ly, w:size, h:size, action:'lvl_'+lvl});
     
     lx += size + gap;
  }
  
  ctx.restore();
}


function triggerOverlayActionAt(x, y){
  // In MENU state, we just clear buttons and rebuild them each frame,
  // so we check the `uiButtons` array populated in drawMenu/drawOverlay.
  for(const b of uiButtons){
    if(x >= b.x && x <= b.x + b.w && y >= b.y && y <= b.y + b.h){
      
      if(gameState === 'menu'){
         if(b.action === 'menu_play'){
             setLevel(currentLevel); 
         } else if(b.action.startsWith('lvl_')){
             currentLevel = parseInt(b.action.split('_')[1]);
         }
         return; // Click handled
      }
    
      if(b.action === 'restart'){ setLevel(1); }
      if(b.action === 'next'){ if(currentLevel < LAST_LEVEL) setLevel(currentLevel+1); }
      if(b.action === 'again_all'){ setLevel(1); }
      break;
    }
  }
}
addEventListener('click', (e)=>{ 
    // Allow clicks in menu too
    if(!(gameState==='win'||gameState==='lose'||gameState==='menu')) return; 
    const r=c.getBoundingClientRect(); 
    triggerOverlayActionAt(e.clientX-r.left, e.clientY-r.top); 
});
let overlayPressedIndex = -1;
addEventListener('touchstart', (e)=>{ 
    if(!(gameState==='win'||gameState==='lose'||gameState==='menu')) return; 
    const t=e.changedTouches[0]; const r=c.getBoundingClientRect(); overlayPressedIndex=-1; const x=t.clientX-r.left; const y=t.clientY-r.top; 
    for(let i=0;i<uiButtons.length;i++){ const b=uiButtons[i]; if(x>=b.x&&x<=b.x+b.w&&y>=b.y&&y<=b.y+b.h){overlayPressedIndex=i; break;} } 
    if(overlayPressedIndex!==-1)e.preventDefault(); 
}, {passive:false});
addEventListener('touchend', (e)=>{ 
    if(!(gameState==='win'||gameState==='lose'||gameState==='menu')) return; 
    if(overlayPressedIndex===-1)return; const t=e.changedTouches[0]; const r=c.getBoundingClientRect(); const b=uiButtons[overlayPressedIndex]; const x=t.clientX-r.left; const y=t.clientY-r.top; 
    if(b&&x>=b.x&&x<=b.x+b.w&&y>=b.y&&y<=b.y+b.h){ triggerOverlayActionAt(x,y); } overlayPressedIndex=-1; e.preventDefault(); 
}, {passive:false});
addEventListener('touchcancel', ()=>{ overlayPressedIndex = -1; });

function checkWinByBodyCenter(prevHB,newHB){
  const yMid=finish.y + finish.h/2;
  const left=finish.x, right=finish.x+finish.w;
  const cxPrev=prevHB.x+prevHB.w/2, cxNew=newHB.x+newHB.w/2;
  const horizInside=(cxPrev>=left&&cxPrev<=right)||(cxNew>=left&&cxNew<=right);
  if(!horizInside) return false;
  const cyPrev=prevHB.y+prevHB.h/2, cyNew=newHB.y+newHB.h/2;
  return ((cyPrev>yMid)&&(cyNew<=yMid));
}

function spawnOnBottomPlatform(){
  let baseIndex = -1; for(let i=0;i<platforms.length;i++){ if(platforms[i].perm){ if(baseIndex===-1 || platforms[i].y>platforms[baseIndex].y) baseIndex=i; } }
  const base = platforms[baseIndex];
  if(!base){ player.x=100; player.y=H-player.h-40; cameraY=0; player.ground=null; return; }
  player.x=Math.max(0,Math.min(BASE_W-player.w,base.x+(base.w-player.w)/2));
  player.y=base.y-player.h; player.vx=0; player.vy=0; player.on=true; player.ground = base; lastGroundTime=timeSec;
  TIMER_TOTAL = getTimerTotal(currentLevel);
  if(currentLevel>=3){
    const targetScreenTop = H - 8 - 24 - player.h;
    const desiredCameraY = base.y - targetScreenTop;
    cameraMaxY = Math.max(cameraMaxY, desiredCameraY); cameraY = Math.max(0, Math.min(cameraMaxY, desiredCameraY));
  } else { cameraY = 0; }
}
function resetTransientForYellow(){
  for(const p of platforms){ 
    if(!p.perm){ p.state='off'; p.prevState='off'; p.tLocal=0; p.grace=0; p.solidDelay=0; p.waitExit=false; setAnim(p,'out',0); if(p.anim) p.anim.alpha=0; } 
  }
}

// ==========================================
// 8. ГЛАВНЫЙ ЦИКЛ (LOOP)
// ==========================================
hoppy.img.onload = ()=>{ 
    hoppy.ready=true; hoppy.naturalW=hoppy.img.naturalWidth; hoppy.naturalH=hoppy.img.naturalHeight; 
    resizeCanvas(); 
    // Не запускаем уровень сразу, а ждем в меню. Но для рендера меню нужен цикл.
    gameState = 'menu';
    requestAnimationFrame(step); 
};

let lastTS=performance.now();
function step(nowTS){
  const dt=Math.min(0.033,(nowTS-lastTS)/1000); lastTS=nowTS;
  
  if(gameState==='menu'){
      ctx.clearRect(0,0,W,H);
      drawMenu(); // Рисуем меню
      requestAnimationFrame(step);
      return;
  }

  if(gameState==='play'){ timeSec+=dt; timerElapsed+=dt; if(timerElapsed>=TIMER_TOTAL) gameState='lose'; }
  if(gameState==='play'){
    let targetVx=0;
    const baseSpeed = SPEED_X * (IS_TOUCH ? MOBILE_SPEED_FACTOR : 1.0);
    if(IS_TOUCH && overrideMove.active){
      if(timeSec <= overrideMove.until){
        if(overrideMove.side < 0){ targetVx -= baseSpeed * NUDGE_SPEED_SCALE; player.dir = -1; }
        else { targetVx += baseSpeed * NUDGE_SPEED_SCALE; player.dir = +1; }
      } else { overrideMove.active = false; keys.left = false; keys.right = false; }
    }
    if(keys.right)targetVx+=baseSpeed; if(keys.left)targetVx-=baseSpeed;
    const accelPerS = player.on ? ACCEL_GROUND_PER_S : (ACCEL_AIR_PER_S * AIR_CONTROL_FACTOR);
    const lerpK = Math.min(1, accelPerS * dt);
    const desired = targetVx;
    const hbSlide = getHitbox();
    const slipperyGround = (player.on && player.ground && player.ground.slippery) ? player.ground : null;
    for(const p of platforms){ if(p.slippery){ if(p !== slipperyGround) p.targetTilt = 0; } }
    if(slipperyGround){
      const pxCenter = slipperyGround.x + slipperyGround.w / 2;
      const playerCenter = hbSlide.x + hbSlide.w / 2;
      const diff = playerCenter - pxCenter;
      if(diff > SLIPPERY_TILT_THRESHOLD) slipperyGround.targetTilt = SLIPPERY_TILT_MAX;
      else if(diff < -SLIPPERY_TILT_THRESHOLD) slipperyGround.targetTilt = -SLIPPERY_TILT_MAX;
      else slipperyGround.targetTilt = 0;
    }
    for(const p of platforms){
      if(p.slippery){
        const tiltNow = (typeof p.tilt === 'number') ? p.tilt : 0;
        const targetTilt = (typeof p.targetTilt === 'number') ? p.targetTilt : 0;
        p.tilt = tiltNow + (targetTilt - tiltNow) * Math.min(1, dt * 6.5);
        p.targetTilt = targetTilt;
      }
    }
    player.vx = player.vx + (desired - player.vx) * lerpK;

    if(slipperyGround){
      if(slipperyGround.tilt > 0) player.vx += SLIDE_ACCEL * dt;
      else if(slipperyGround.tilt < 0) player.vx -= SLIDE_ACCEL * dt;
    }
    
    if(Math.abs(desired) < 1){ player.vx = applyFriction(player.vx, player.on, dt); }
    
    const canCoyote=(timeSec-lastGroundTime)<=COYOTE;
    const buffered=(timeSec-lastJumpPress)<=BUFFER;
    if(buffered&&(player.on||canCoyote)){ player.vy=JUMP_VY; player.on=false; lastJumpPress=-1; }
    const prevHB=getHitbox(); const prevBottom=prevHB.y+prevHB.h;
    player.vy+=G*dt; if(player.vy>MAX_FALL)player.vy=MAX_FALL; if(player.vy<-MAX_RISE)player.vy=-MAX_RISE; _applyPendingJumpScale();
    player.x+=player.vx*dt; player.y+=player.vy*dt; player.on=false;
    if(currentLevel>=3){ const camTarget = Math.max(0, Math.min(cameraMaxY, player.y - H*0.60)); cameraY += (camTarget - cameraY) * 0.12; }
    const hb=getHitbox();
    if((currentLevel === 4 || currentLevel === 5) && cookie && !cookie.taken){
      const cx = cookie.x - cookie.r;
      const cy = cookie.y - cookie.r;
      const cw = cookie.r * 2;
      const ch = cookie.r * 2;
      if(hb.x < cx + cw && hb.x + hb.w > cx &&
         hb.y < cy + ch && hb.y + hb.h > cy){
        cookie.taken = true;
        timerElapsed = Math.max(0, timerElapsed - 1.5);
      }
    }
    for(const p of platforms){ if(!p.perm) updateBridgeState(p,dt,hb); }
    const newHB=getHitbox(); const newBottom=newHB.y+newHB.h;
    if(player.vy>=0){
      player.ground = null;
      for(const p of platforms){
        if(!bridgeIsSolidForLanding(p)) continue;
        const top=p.y,left=p.x,right=p.x+p.w;
        const ow=Math.min(newHB.x+newHB.w,right)-Math.max(newHB.x,left);
        const enough=ow>=MIN_OVERLAP;
        const crossed=(prevBottom<top && newBottom>=top) || (Math.abs(newBottom-top)<=TOP_TOLERANCE);
        if(enough&&crossed){
          if(!p.perm && p.grace>0) p.grace=0;
          player.y=top-newHB.h-HITBOX_OFFSET_Y; player.vy=0; player.on=true; player.ground = p; lastGroundTime=timeSec; break;
        }
      }
    }
    if(checkWinByBodyCenter(prevHB,newHB)) gameState='win';
    const offRight=player.x>BASE_W+40, offLeft=player.x+player.w<-40;
    const offBottom = (currentLevel>=3) ? ((player.y - cameraY) > H + 140) : (player.y>BASE_H+80);
    if(offBottom || offRight || offLeft){ gameState='lose'; }
  }
  ctx.globalAlpha = 1; ctx.globalCompositeOperation = 'source-over';
  ctx.clearRect(0,0,W,H);
  let offsetXBase = Math.round((W - BASE_W) / 2);
  let offsetX = offsetXBase;
  
  drawButton(); 
  drawPlatforms(offsetX); 
  drawCookie(offsetX);
  drawHoppy(offsetX); 
  drawTimer();
  if(gameState==='win'){
    if(currentLevel < LAST_LEVEL){
      drawOverlay({text:'Протокол остановлен (Уровень '+currentLevel+')', color:'#2ecc71'}, [ {label:'Дальше', action:'next'}, {label:'Заново', action:'restart'} ]);
    } else {
      drawOverlay({text:'Протокол остановлен (Все уровни)', color:'#2ecc71'}, [ {label:'Заново', action:'again_all'} ]);
    }
  }
  if(gameState==='lose'){ drawOverlay({text:'Очистка выполнена', color:'#c0392b'}, [ {label:'Заново', action:'restart'} ]); }
  if (gameState === 'win' || gameState === 'lose') { overlayClock += dt; }
  requestAnimationFrame(step);
}

resizeCanvas();

addEventListener('keydown',e=>{ if(gameState!=='play')return; if(e.key==='ArrowLeft'||e.key==='a'){keys.left=true; player.dir=-1;} if(e.key==='ArrowRight'||e.key==='d'){keys.right=true; player.dir=1;} if(e.key==='ArrowUp'||e.key==='w'||e.code==='Space'){ if(!keys.up){lastJumpPress=timeSec; player.jumpHeld=true;} keys.up=true; e.preventDefault(); } });
addEventListener('keyup',e=>{ if(e.key==='ArrowLeft'||e.key==='a') keys.left=false; if(e.key==='ArrowRight'||e.key==='d') keys.right=false; if(e.key==='ArrowUp'||e.key==='w'||e.code==='Space'){ keys.up=false; player.jumpHeld=false; if(player.vy<0) player.vy *= 0.55; e.preventDefault(); } });
addEventListener('keydown',(e)=>{ if(e.key==='r'||e.key==='R'){ setLevel(currentLevel); } if((e.key==='Enter') && (gameState === 'win' || gameState === 'lose')){ if(gameState==='win' && currentLevel < LAST_LEVEL) setLevel(currentLevel+1); else setLevel(currentLevel); } });
</script>
</html>
